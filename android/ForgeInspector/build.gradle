apply plugin: "com.android.application"

android {
    compileSdkVersion rootProject.ext.compileSdkVersion
    buildToolsVersion rootProject.ext.buildToolsVersion

    defaultConfig {
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        compileOptions rootProject.ext.compileOptions
        resConfigs moduleResConfigs()
        manifestPlaceholders = moduleManifestPlaceholders()
    }

    flavorDimensions "default"

    productFlavors {
        vanilla {
            dimension "default"
        }
    }

    sourceSets {
        main {
            manifest.srcFile "AndroidManifest.xml"
            java.srcDirs = ["src"]
            resources.srcDirs = ["src"]
            aidl.srcDirs = ["src"]
            renderscript.srcDirs = ["src"]
            res.srcDirs = ["res"] + new File("ForgeInspector").listFiles().findAll {
                it.isDirectory() and it.name.startsWith("res_module_")
            }.collect {
                println "Added module resource directory: " + it
                it.name
            }
            assets.srcDirs = ["assets"]
        }
    }

    buildTypes {
        debug rootProject.ext.debug
        release rootProject.ext.release << {
            proguardFile getDefaultProguardFile("proguard-android.txt")
            proguardFile "proguard-project.txt"
        }
    }

    lintOptions {
        abortOnError false
    }

    aaptOptions {
    }

    packagingOptions {
        // workaround misc META-INF dupe issues with older customer modules
        pickFirst "META-INF/DEPENDENCIES"
        pickFirst "META-INF/NOTICE"
        pickFirst "META-INF/LICENSE"
        pickFirst "META-INF/LICENSE.txt"
        pickFirst "META-INF/NOTICE.txt"
    }

    dexOptions {
        preDexLibraries false
    }
}

dependencies {
    vanillaImplementation project(path: ":ForgeCore")

    // add module dependencies
    implementation moduleDependencies()
    implementation fileTree(dir: "libs", include: ["*.jar"], exclude: moduleExcludeJars())

    // make sure app versions are prioritized over module versions
    implementation rootProject.ext.dependencies

    fileTree(dir: "libs", include: "**/*-vanilla-release.aar")
    .each { File file ->
        def name = file.name.lastIndexOf(".").with { it != -1 ? file.name[0..<it] : file.name }
        dependencies.add("vanillaImplementation", [name: name , ext: "aar"])
        println "Added module aar for vanilla: $name"
    }
}

// repo for module aars
repositories{
    flatDir {
        dirs "libs"
    }
}


task assembleVanillaAPK(dependsOn: "assembleVanillaRelease") {
    doLast {
        println "Unzipping APK"
        copy {
            from zipTree("build/outputs/apk/vanilla/release/ForgeInspector-vanilla-release-unsigned.apk")
            into "apk"
        }
    }
}

task assembleVanillaAAB(dependsOn: "bundleVanillaRelease") {
    doLast {
        println "Unzipping AAB"
        copy {
            from zipTree("build/outputs/bundle/vanillaRelease/ForgeInspector-vanilla-release.aab")
            into "aab"
        }
    }
}


// Apply custom gradle plugins
for (Object plugin : moduleGradlePlugins()) {
    println "Applying gradle plugin: " + plugin
    project.plugins.apply(plugin.name);
}
